#include <iostream>
#include <vector>
#include <fstream>
using namespace std;

ostream& operator<< (ostream& out, const vector<int>& vect) {
	//ostream& operator<< (ostream& out, const vector<int> vect) {
	out << vect.size() << "\t" << "| ";
	for (int i = 0; i < vect.size(); i++) out << &vect[i] << " ";
	return out;
}

int main()
{
	vector<int> v;
	ofstream data_txt("data1.txt");

	for (int i = 0; i < 64; i++) {
		v.push_back(i);
		data_txt << v << endl;
	}

	while (v.size()) {
		v.pop_back();
		data_txt << v << endl;
	}
}

// Пояснения по заданию 31.
// 
// При изучении вывода я увидила закономерность, что для вектора, переданного
// по ссылке память выделяестся с запасом. Пока этот запас не израсходован, вектор
// находится в этом участке памяти. Как только место заканчивается, вектор получает
// новое место в памяти, которое в полтора раза больше, чем было предыдущее.
// Вот так вот изменяются объёмы выделенного места: 2, 3, 4, 6, 9, 13, 19, 28, 42, 63, 94
// Например, если размер вектора 13 и добавить один элемент, то начальный адрес вектора
// изменится и уже потом будет увеличиваться вплоть до 19 элементов, и только с 20
// элементом начальный адрес вектора опять поменяется.
// 
// Ещё я заметила, что адреса вектора всегда идут по порядку. Как я понимаю, это нужно
// для правильного последовательного доступа к его элементам.
// 
// Поэтому, если запомнить адрес 15 элемента, а потом, когда вектор достигнет размера 25,
// попробовать поменять значение 15-го элемента, то ничего не получится, так как вектор уже,
// наверняка будет в другом участвке памяти. После 19 элементов произойдёт его перемещение.
// 
// Если уменьшать размеры вектора, то он будет продолжать находиться на том же самом месте и
// адрес его первого элемента будет одинаковым. Это может означать, что за вектором останется
// тот максимальный кусок памяти, который он когда-либо получал.
// 
// Когда мы передаём вектор по значению, то памяти ему выделяется ровно столько, сколько 
// ему сейчас нужно и запаса не делается. Но по выводу об этом очень сложно судить. Эту
// информацию я дополнительно прочитала в интернете.
// И при уменьшенн, вектор сразу будет отдавать память назад по убраным последним элементам.
// 